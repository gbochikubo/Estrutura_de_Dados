#include <iostream>
#include <cstdlib>

using namespace std;

typedef int dado;

class noh{
    
    friend class lista;
    
    private:
        dado _dado;
        noh* prox;
        noh* ant;
    
    public:
        noh(dado d=0);
};

noh::noh(dado d){
    this->_dado = d;
    this->prox = NULL;
    this->ant = NULL;
}

class lista {
    private:
        int tamanho;
        noh* primeiro;
        noh* ultimo;
        void removeTodos();
    
    public:	
        lista();
        lista(const lista& umalista);
        lista(const dado umdado[],int tamanho);
        ~lista();
        void imprime();
        void imprimeReversoAux(noh* umNoh);
        void imprimeReverso();
        void insereNoFim(dado d);
        void insereNoInicio(dado d);
        void insereNaPosicao(int posicao,dado d);
        inline bool vazia();
        void insere(dado d);
        void removeNaPosicao(int posicao);
        void removeDado(dado d);
        void imprimeAnt();
        noh* acessaPosicao( int posicao);
        dado acessaDado( int posicao);
        int procuraDado(dado x);
        void bubble();
        void buscaBinaria(dado x);
        lista& operator = (const lista& umalista);
        void troca(int p1, int p2);
        void test();
        lista& operator + (const lista& umalista);
        lista& operator - (const lista& umalista);
        void removeDuplicado();
        void divide(int n);
};  

lista::lista(){
    this->primeiro = NULL;
    this->ultimo = NULL;
    this->tamanho = 0;

}

lista::~lista(){
    removeTodos();
}

lista::lista(const lista& umalista){
    this->primeiro = NULL;
    this->ultimo = NULL;
    this->tamanho = 0;
    
    noh* aux = umalista.primeiro;
    
    while (aux != NULL){
        
        insereNoFim(aux->_dado);
        aux = aux->prox;
    }
}

lista::lista (const dado umdado[],int tamanho){
    
    this->primeiro = NULL;
    this->ultimo = NULL;
    this->tamanho = 0;

    
    for(int i = 0;i < tamanho; i++){

    insereNoFim(umdado[i]);

    }

}
lista& lista::operator =(const lista& umalista){
    
    
    removeTodos(); // a lista que foi limpada foi a atual
    
    noh* aux = umalista.primeiro;
    while( aux != NULL){
        
        insereNoFim(aux->_dado);
        aux = aux->prox;
    }
    return *this;  // retorna o ponteiro do que foi alterado para o novo objeto
}

lista& lista:: operator +(const lista& umalista){
        
        noh* aux = umalista.primeiro;
        
        while (aux != NULL){
            
            insereNoFim(aux->_dado);
            aux = aux->prox;
            tamanho++;
        }
        return *this;
}

lista& lista:: operator -(const lista& umalista){
        
        noh* aux = umalista.primeiro;
        noh* original = primeiro;
        
        while (aux != NULL){
          
            while (original != NULL){
       
            if(aux->_dado == original->_dado){
                removeDado(original->_dado);
                
            }
            original = original->prox;
        }
        aux = aux->prox;
        original = primeiro;
        
    }
    return *this;
}                
        
    
    

void lista::bubble(){
    bool trocou;
    
    while(trocou) {
        trocou = false;
        
        for (int i = 0; i < tamanho-2; i++)
        {
            if (acessaDado(i) > acessaDado(i+1)) {
                troca(i, i+1);
                trocou = true;                    
            }
        }
    } 
}

void lista :: removeDuplicado(){
        
        noh* original;
        noh* aux = primeiro;
        original = aux->prox;
        
       
            
        while ((aux != NULL)and(original != NULL)){
            //~ cout << "AUX" << " " << aux->_dado << endl;
            //~ cout << "ORIGINAL" << " " <<  original->_dado << endl << endl;
            
          
            while (original != NULL){
                //~ cout << "ORIGINAL ANTES DA REMOÇAO" << "  " << original->_dado << endl;
            if ( aux-> _dado == original->_dado){
                    
                    
                    removeDado(original->_dado);
                }
                //~ cout << "ORIGINAL DENTRO DO WHILE" << "    "  << original->_dado << endl;
                original = original->prox;
            }
            aux = aux->prox;
            original = aux->prox;
        }
    }
                    

    
    

void lista::removeTodos(){

    noh* aux = primeiro;
    noh* temp;
    
    while (aux != NULL){
        temp = aux;
        aux = aux->prox;
        delete temp;
    }
    primeiro = NULL;
    ultimo = NULL;
    tamanho = 0;
}


inline bool lista:: vazia(){

	return (primeiro == NULL);
}



void lista::insere(dado d){
    insereNoFim(d);
}

dado lista :: acessaDado (int posicao){
    
     if((posicao >=0) and (posicao <= tamanho)) {
        noh* elemento = primeiro;
        
        for( int i = 0; i < posicao; i++)
            elemento = elemento->prox;
        
        return (elemento->_dado);
    } else {
        cerr << "Posicao invalida!" << endl;
        return dado(0);
    }
}
    
    

noh* lista::acessaPosicao(int posicao) {
    if((posicao >=0) and (posicao <= tamanho)) {
        noh* elemento = primeiro;
        
        for( int i = 0; i < posicao; i++)
            elemento = elemento->prox;
        
        return elemento;
    } else {
        cerr << "Posicao invalida!" << endl;
        return NULL;
    }
}

void lista::insereNoFim(dado d){
    
    noh* novo = new noh (d);
    
    if(vazia()){
        
        primeiro = novo;
        ultimo = novo;
    }
    
    else {
            
        ultimo->prox = novo;
        novo->ant = ultimo;
        ultimo = novo;
    }
    tamanho ++;
}

int lista::procuraDado(dado x){
    
    int posaux = 0;
    noh* aux = primeiro;
    while ((aux != NULL) and (aux->_dado != x)){
        aux = aux->prox;
        posaux++;
    }
    return (posaux);
}

/*noh* lista :: acessa_posicao(int p){
    
    
    noh* aux = primeiro;
    if ((p >=0) and (p <= tamanho)){
        
        for(int i = 0; i < p; i++){
            aux = aux->prox;
        }
    }
    return aux;
}*/

void lista::imprimeReverso(){
    imprimeReversoAux(primeiro);
    cout << endl;
   // imprimeReversoAux(ultimo);
    
}

void lista::imprimeAnt(){
    noh* Aux = ultimo;
    while(Aux != NULL){
        cout << Aux->_dado << " ";
        Aux=Aux->ant;
    }
    cout << endl;
}

void lista::imprimeReversoAux(noh* umNoh){
    if(umNoh != NULL){                      // se o nó nao for nulo, imprimeReversoAux( nó->prox);
        
        imprimeReversoAux(umNoh->prox);
        cout << umNoh->_dado << " ";
    }
}

void lista:: buscaBinaria(dado x){
    
    bubble();
    int inicio = 0;
    int fim = tamanho-1;
    int meio;
    int posicao=-1;
    while (inicio <= fim){
        meio = (inicio+fim)/2;
        
        if (x == acessaDado(meio)){
                posicao = meio;
                inicio = fim+1;
            }
        else {
            
            if (x > acessaDado(meio)){
                    inicio = meio+1;
                }
                else {
                    fim = meio-1;
                }
            }
        }
    if (posicao == -1){
        cout << "DADO INVALIDO" << endl;
    }
    else {
        cout << posicao << endl;
    }
}
                
        

void lista::imprime(){
    
    noh* aux = primeiro;
    
    while(aux != NULL){
        cout << aux->_dado << " ";
        aux = aux->prox;
    }
    cout << endl;
}

void lista::insereNoInicio(dado d){
    
    noh* novo = new noh(d);
    
    if(vazia()){
    
        primeiro = novo;
        ultimo = novo;
    }
    else {
    
        novo->prox = primeiro;
        primeiro->ant = novo;
        primeiro = novo;
    }
    tamanho ++;
}

void lista::insereNaPosicao(int posicao,dado d){
    
    noh* novo = new noh(d);
    int posAux = 1;
    noh* aux = primeiro;
    if ((posicao <= tamanho) and (posicao >= 0)){
    if(posicao == 0){
        insereNoInicio(d);
    }
    else if(posicao == tamanho){
        insereNoFim(d);
    }
    else {
        
        while (posAux < posicao-1){
                
            aux = aux->prox;
            posAux++;
        }
        
        novo->prox=aux->prox;
        aux->prox = novo;
        novo->ant = aux;
        aux = novo;
        }
    tamanho ++;
    }
    else {
        cerr << "Posicao Invalida ! " << endl;
        exit(EXIT_FAILURE);
    }
}

void lista::removeNaPosicao(int posicao){
    
    if ((posicao >= 0 ) and ( posicao <= tamanho)){
        if(posicao == 0){
            noh* AuxAnterior = primeiro;
            primeiro = primeiro->prox;
            primeiro->ant = NULL;
            delete AuxAnterior;
        }
       else {
        
            int posAux = 1;
            noh* aux = primeiro->prox;
            noh* anterior = primeiro;
        
            while (posAux < posicao){
        
                anterior = aux;
                aux = aux->prox;
                posAux++;
            }
            if (aux == ultimo){
                anterior->prox = NULL;
                ultimo = anterior;
                delete aux;
            }
            else {
            anterior->prox = aux->prox;
            noh* auxiliar = aux->prox;
            auxiliar->ant = anterior;
            delete aux;
            }
        }
    }
}

void lista::removeDado(dado d){
    
   // noh* aux = new noh(d);
    noh* original = primeiro;
    bool trocou=true;
    while ( original != NULL){
        if(original->_dado == d){
            if ((original == primeiro)and(trocou)){
                noh* AuxAnterior = primeiro;
                primeiro = primeiro->prox;
                primeiro->ant = NULL;
                delete AuxAnterior;
                trocou= false;
            }
            else if(( original == ultimo)and(trocou)){
                noh* anterior = ultimo->ant;
                anterior->prox = NULL;
                ultimo = anterior;
                
                trocou = false;
            }
            else {
                if(trocou){
                noh* aux = original;
                noh* anterior = original->ant;
                noh* proximo = original->prox;
                anterior->prox = proximo;
                proximo->ant = anterior;
                delete aux;
                trocou = false;
                }
                
            }
            tamanho--;
        }
        original = original->prox;
      
    }
}             
            
                
            
    


void lista::troca (int p1, int p2){

    int x,y;
    if(p1 > p2){
        y = p1;
        x = p2;
    }
    else {
        y = p2;
        x = p1;
    }
    
    if ((x == 0 ) and (y == tamanho-1)){
    
     noh* Prim_prox = primeiro->prox; //  primeiro prox
     noh* Ult_ant = ultimo->ant;   // ultimo ant
     noh* pri = primeiro;   
     noh* ult = ultimo;
     Prim_prox->ant = ultimo;  // (2 elemento)->ant = ultimo
     Ult_ant->prox = primeiro; // (penultimo elemento)->prox = primeiro
     pri->ant = Ult_ant; // primeiro anterior = ultimo anterior
     ult->prox = pri->prox; // ultimo proximo = primeiro prox
     ult->ant = NULL; // ultimo anterior = NULL
     pri->prox = NULL; // primeiro proximo = NULL
     ultimo = pri;
     primeiro = ult;
    }
    
    else if (((y-x) == 1) and (x == 0)){
        
        noh* aux = primeiro;
        noh* auxProx = primeiro->prox;
        noh* terElemento = auxProx->prox;
        terElemento->ant = aux;
        aux->prox = terElemento;
        aux->ant = auxProx;
		auxProx->prox = aux;
		auxProx->ant = NULL;
		primeiro = auxProx;
		primeiro->prox = aux;
	}
	
	else if (((y-x) == 1) and (y == tamanho-1)){
		
		noh* aux = ultimo;
		noh* penultimo= ultimo->ant;
		noh* antipenultimo = penultimo->ant;
		
		aux->ant = antipenultimo;
		penultimo->ant = aux;
		antipenultimo->prox = aux;
		aux->prox = penultimo;
		penultimo->prox = NULL;
		
		ultimo = penultimo;
	}
	
	else if((y-x)==1){
		
		noh* anterior = acessaPosicao(x-1);
		noh* proximo = acessaPosicao(y+1);
		noh* auxX = acessaPosicao(x);
		noh* auxY = acessaPosicao(y);
		
		anterior->prox = auxY;
		auxY->prox = auxX;
		auxX->prox = proximo;
		auxY->ant = anterior;
		auxX->ant = auxY;
		proximo->ant = auxX;
	
	}
	
	else if((x == 0) and (y != tamanho-1)){
		
		cout<<"ENTROU" << endl;
		noh* auxX = acessaPosicao(x);
		noh* auxY = acessaPosicao(y);
		noh* proximoX = auxX->prox;
		noh* proximoY = auxY->prox;
		noh* anteriorY = auxY->ant;
		
		
		auxX->prox = proximoY;
		anteriorY->prox = auxX;
		auxY->prox = proximoX;
		proximoY->ant = auxX;
		auxX->ant = anteriorY;
		proximoX->ant = auxY;
		auxY->ant = NULL;
		primeiro = auxY;
	}
	
	else if((y == tamanho -1) and (x != 0)){
		
		noh* auxX = acessaPosicao(x);
		noh* auxY = acessaPosicao(y);
		noh* anteriorX = auxX->ant;
		noh* anteriorY = auxY->ant;
		noh* proximoX = auxX->prox;
		
		auxY->ant = anteriorX;
		auxX->ant = anteriorY;
		proximoX->ant = auxY;
		anteriorX->prox = auxY;
		auxY->prox = proximoX;
		anteriorY->prox = auxX;
		auxX->prox = NULL;
		ultimo = auxX;
	}
	
	else {
		
		noh* auxX = acessaPosicao(x);
		noh* auxY = acessaPosicao(y);
		noh* anteriorX = auxX->ant;
		noh* anteriorY = auxY->ant;
		noh* proximoX = auxX->prox;
		noh* proximoY = auxY->prox;
		
		anteriorX->prox=auxY;
		auxX->prox = proximoY;
		anteriorY->prox = auxX;
		auxY->prox = proximoX;
		proximoY->ant = auxX;
		auxY->ant = anteriorX;
		auxX->ant = anteriorY;
		proximoX->ant = auxY;
	}
		
}

//void lista :: divide(int n){
    
     

int main (){
    
    lista list;
    
    list.insere(10);
    list.insere(20);
    list.insere(30);
    list.insere(10);
    list.insere(50);
    list.insere(60);
    list.insere(30);
    
    lista list2;
    list2.insere(30);
    list2.insere(2);
    list2.insere(20);
    list2.insere(40);
    list2.insere(5);
   
    lista list3;
    
    list3 = list-list2;
    list3.imprime();
    list.buscaBinaria(100);
    
    
    
    return 0;
}
